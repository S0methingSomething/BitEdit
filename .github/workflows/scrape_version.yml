name: Check BitLife Version and Update File

on:
  schedule:
    # Runs at 2 AM UTC every Sunday.
    # For Cordon, Cagayan Valley, Philippines (PHT), this is 10 AM on Sunday.
    - cron: '0 2 * * 0'
  workflow_dispatch: # Allows manual runs from the Actions tab

permissions:
  contents: write # Needed to commit the version.txt file AND to update repository variables via gh CLI

jobs:
  check-and-update: # This is the name of our job
    runs-on: ubuntu-latest # Use the latest available Ubuntu runner
    
    env:
      # Load the last known version from the repository variable we created
      LAST_KNOWN_VERSION: ${{ vars.LATEST_BITLIFE_VERSION }}

    steps: # A sequence of steps to run for this job
      # Step 1: Check out your repository's code
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Set up the Python version we want to use
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      # Step 3: Install the Python libraries needed by your script
      - name: Install dependencies from specific path
        run: pip install -r BitEdit/Get_Bitlife_Version/requirements.txt

      # Step 4: Run your Python script to get the current version
      # The output of this script (the version number) is captured.
      - name: Scrape for current version
        id: scrape # Give this step an ID so we can refer to its output
        run: echo "current_version=$(python BitEdit/Get_Bitlife_Version/Get_version.py)" >> $GITHUB_OUTPUT

      # Step 5: A debug step to print the version captured by the script
      # This helps us see what the script actually outputted.
      - name: Debug Print Scraped Version
        run: echo "Scraped version output by script is --->${{ steps.scrape.outputs.current_version }}<---"

      # Step 6: Create the version.txt file, but ONLY if a new version is found
      - name: Create file if new version is found
        # This 'if' condition checks:
        # 1. If the scraped version is not empty (steps.scrape.outputs.current_version)
        # 2. AND if the scraped version is different from the last known version
        if: steps.scrape.outputs.current_version && steps.scrape.outputs.current_version != env.LAST_KNOWN_VERSION
        run: | # The '|' allows for a multi-line script here
          echo "New version found: ${{ steps.scrape.outputs.current_version }}. Creating file..."
          echo "${{ steps.scrape.outputs.current_version }}" > BitEdit/Get_Bitlife_Version/version.txt

      # Step 7: Commit the new version.txt file to your repository
      # This step also only runs if a new version was found.
      - name: Commit new version file
        if: steps.scrape.outputs.current_version && steps.scrape.outputs.current_version != env.LAST_KNOWN_VERSION
        uses: stefanzweifel/git-auto-commit-action@v5 # A pre-made action for auto-commits
        with:
          commit_message: "ðŸš€ Update BitLife version to ${{ steps.scrape.outputs.current_version }}"
          # Tell the action to only commit changes to this specific file
          file_pattern: 'BitEdit/Get_Bitlife_Version/version.txt'
          
      # Step 8: Update the repository variable with the new version number
      # This also only runs if a new version was found.
      - name: Update repository variable with new version
        if: steps.scrape.outputs.current_version && steps.scrape.outputs.current_version != env.LAST_KNOWN_VERSION
        run: |
          echo "Updating LATEST_BITLIFE_VERSION variable to ${{ steps.scrape.outputs.current_version }}"
          # Use the GitHub CLI (gh) to update the variable
          gh variable set LATEST_BITLIFE_VERSION --body "${{ steps.scrape.outputs.current_version }}"
        env:
          # The GH_TOKEN is a special secret automatically provided to workflows
          # by GitHub, allowing it to interact with your repository.
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
